// use rand::Rng;

// enum Note {
//     C,
//     C_,
//     D,
//     D_,
//     E,
//     F,
//     F_,
//     G,
//     G_,
//     A,
//     A_,
//     B,
// }

// enum Division {
//     QUARTER,
//     EIGHT,
//     SIXTEEN,
// }

// struct DivNote {
//     note: Note,
//     division: Division,
// }

// pub const CHORD_SEQUENCE: Vec<Vec<String>> = [
//     ["I", "IV", "V"],
//     ["ii", "V", "I"],
//     ["vi", "IV", "I", "V"],
//     ["I", "V", "vi", "IV"],
//     ["I", "vi", "ii", "V"],
//     ["i", "iv", "V"],
//     ["I", "iii", "vi", "V"],
//     ["ii", "V", "I"],
//     ["I", "bVII", "IV", "I"],
//     ["I", "bVI", "IV", "V"],
// ];

// struct ChordSequence {
//     key: &str,
//     sequence: Vec<Note>,
// }

// pub fn notes() -> [&str; 12] {
//     return [
//         "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B",
//     ];
// }

// pub fn get_keys() -> [&str; 12] {
//     notes()
// }

// pub fn generate_arpeggios_for_progression(chord_sequence: ChordSequence) -> usize {
//     todo!()
// }
